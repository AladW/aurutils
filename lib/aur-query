#!/bin/bash
# aur-query - interface with AurJson
[[ -v AUR_DEBUG ]] && set -o xtrace
argv0=query
AUR_LOCATION=${AUR_LOCATION:-'https://aur.archlinux.org'}
AUR_QUERY_PARALLEL=${AUR_QUERY_PARALLEL:-1}
AUR_QUERY_PARALLEL_MAX=${AUR_QUERY_PARALLEL_MAX:-15}
PS4='+(${BASH_SOURCE}:${LINENO}):${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# default arguments
curl_args=(-fgLsS --tcp-fastopen)

uri_info() {
    #global rpc_url
    awk -v rpc="$rpc_url&type=info" '{
        if (NR == 1)
            printf "%s&arg[]=%s", rpc, $0
        else if (NR % 150 == 0)
            printf "\n%s&arg[]=%s", rpc, $0
        else if (NR > 1)
            printf "&arg[]=%s", $0
    } END {
        if (NR != 0)
            printf "\n"
    }'
}

uri_search() {
    #global rpc_url
    awk -v rpc="$rpc_url&type=search&by=$1&arg" '{
        printf "%s=%s\n", rpc, $0
    }'
}

trap_exit() {
    if [[ ! -v AUR_DEBUG ]]; then
        rm -rf -- "$tmp"
    else
        printf >&2 'AUR_DEBUG: %s: temporary files at %s\n' "$argv0" "$tmp"
    fi
}

usage() {
    printf 'usage: %s [-t [info|search] ] [-b by]\n' "$argv0" >&2
    exit 1
}

source /usr/share/makepkg/util/parseopts.sh

opt_short='b:t:'
opt_long=('by:' 'type:' 'rpc-ver:' 'rpc-url:')
opt_hidden=('dump-options')

if ! parseopts "$opt_short" "${opt_long[@]}" "${opt_hidden[@]}" -- "$@"; then
    usage
fi
set -- "${OPTRET[@]}"

unset arg_by arg_type rpc_url rpc_ver
while true; do
    case "$1" in
        -b|--by)
            shift; arg_by=$1 ;;
        -t|--type)
            shift; arg_type=$1 ;;
        --rpc-ver)
            shift; rpc_ver=$1 ;;
        --rpc-url)
            shift; rpc_url=$1 ;;
        --dump-options)
            printf -- '--%s\n' "${opt_long[@]}" ${AUR_DEBUG+"${opt_hidden[@]}"}
            printf -- '%s' "${opt_short}" | sed 's/.:\?/-&\n/g'
            exit ;;
        --) shift; break ;;
    esac
    shift
done

tmp=$(mktemp -d --tmpdir "aurutils-$argv0.XXXXXXXX") || exit
trap 'trap_exit' EXIT

# set AUR remote
rpc_ver=${rpc_ver:-5}
rpc_url=${rpc_url:-$AUR_LOCATION/rpc/?v=$rpc_ver}

# set filters
case $arg_type in
      info) uri_write() { uri_info; } ;;
    search) uri_write() { uri_search "${arg_by:-name-desc}"; } ;;
         *) usage ;;
esac

# check for interactive terminal
if [[ -t 0 ]]; then
    cat >&2 <<EOF
Warning: Input is read from the terminal. You either know what you
Warning: are doing, or you forgot to pipe data into $argv0.
Warning: Press CTRL-D to exit.
EOF
fi

# generate curl config
if (( AUR_QUERY_PARALLEL )); then
    mkdir "$tmp"/out
    unset i

    jq -R -r '@uri' | uri_write | while IFS= read -r uri; do
        i=$((i+1))

        printf 'url %s\n' "$uri"
        printf 'output %q\n' "$tmp/out/$i"
    done > "$tmp"/config

else
    jq -R -r '@uri' | uri_write | while IFS= read -r uri; do
        printf 'url "%s"\n' "$uri"
    done > "$tmp"/config
fi

# exit cleanly on empty input (#706)
if [[ ! -s $tmp/config ]]; then
    exit
fi

if (( AUR_QUERY_PARALLEL )); then
    # support parallel transfers (curl >7.66.0)
    curl "${curl_args[@]}" -K "$tmp"/config --stderr "$tmp"/error \
         --parallel --parallel-max "$AUR_QUERY_PARALLEL_MAX"

    # curl --parallel does not exit >0 on failed transfers, thus
    # stderr has to be checked manually
    if (( $? )) || [[ -s $tmp/error ]]; then
        sort "$tmp"/error | uniq -c >&2
        exit 1
    else
        cat "$tmp"/out/*
    fi
else
    curl "${curl_args[@]}" -K "$tmp"/config
fi

# vim: set et sw=4 sts=4 ft=sh:
