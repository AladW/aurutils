#!/bin/bash
# aur-sync - download and build AUR packages automatically
set -o errexit -o pipefail -o noclobber
shopt -s nullglob
readonly argv0=sync
readonly XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
readonly AURDEST=${AURDEST:-$XDG_CACHE_HOME/aurutils/$argv0}
readonly AURDEST_SNAPSHOT=${AURDEST_SNAPSHOT:-$XDG_CACHE_HOME/aurutils/snapshot}
readonly AURVCS=${AURVCS:-.*-(bzr|git|hg|svn)$}
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# default arguments
build_args=()
fetch_args=()
makechrootpkg_args=(-cu)
makechrootpkg_makepkg_args=()
makepkg_args=(-cs)

# default options (enabled)
build=1 chkver=1 download=1 view=1

# default options (disabled)
chroot=0 list=0 rotate=0 snapshot=0 update=0 provides=0 repo_list=0 devel=0

viewer() {
    if type -P vifm >/dev/null; then
        vifm - '+view!'
    else
        command -- "${PAGER:-less}"
    fi
}

lib32() {
    awk -v arch="$(uname -m)" '{
        if(arch == "i686") {
            gsub(/^lib32-/,"")
            gsub(/^gcc-multilib$/,"")
        }; print
    }'
}

conf_file_repo() {
    awk -F'= ' '
        $1 ~ /^\[.+\]$/ {
            repo = substr($1, 2, length($1)-2)
        }
        $1 ~ /^Server/ && $2 ~ /^file:/ {
            printf("%s\n%s\n", repo, $2)
        }'
}

db_namever() {
    awk '/%NAME%/ {
        getline
        printf("%s\t", $1)
    }
    /%VERSION%/ {
        getline
        printf("%s\n", $1)
    }'
}

db_fill_empty() {
    awk '{print} END {
        if (!NR)
            printf("%s\t%s\n", "(none)", "(none)")
    }'
}

select_pkgbase() {
    awk 'NR == FNR {
            a[$0]; next
        } {
            if($1 in a && !($2 in seen)) {
                print $0; seen[$2]
            }
        }' "$@"
}

complement() {
    # empty set should not return 1
    grep -Fxvf "$@" || return $(($?-1))
}

trap_exit() {
    if [[ ! -o xtrace ]]; then
        rm -rf "$tmp" "$tmp_view"
    fi
}

usage() {
    plain "usage: $argv0 [-ABcDfglLprstTu] [long options] [--] pkgname... [-]"
    exit 1
}

source /usr/share/makepkg/util/util.sh
source /usr/share/makepkg/util/message.sh

if [[ -t 2 && ! -o xtrace ]]; then
    colorize
fi

if getopt -T || (($? != 4)); then
    error "$argv0: util-linux getopt required"
    exit 22
fi

longopts=allan,bind:,chroot,directory:,force,ignore:,ignorearch,ignore-arch,log
longopts+=,noconfirm,no-confirm,nover,no-ver,noview,no-view,print,rmdeps,rm-deps
longopts+=,sign,temp,tar,repo:,database:,root:,upgrades,nhehgvyf,continue,list,git
longopts+=,makepkg-conf,pacman-conf,provides,repo-list,devel
shortopts=d:D:AcfglLnprstTu

if optstring=$(getopt -o "$shortopts" -l "$longopts" -n "$argv0" -- "$@"); then
    eval set -- "$optstring"
else
    usage
fi

tmp=$(mktemp -dt "$argv0".XXXXXXXX)
tmp_view=$(mktemp -dt view.XXXXXXXX)
trap 'trap_exit' EXIT

unset pkg pkg_i root repo
while true; do
    case "$1" in
        -c|--chroot)
            chroot=1
            build_args+=(-c)
            shift ;;
        -f|--force)
            build_args+=(-f)
            shift ;;
        -s|--sign)
            build_args+=(-sv)
            shift ;;
        -D|--directory)
            build_args+=(-D "$2")
            shift 2 ;;
        --makepkg-conf)
            build_args+=(-M "$2")
            shift 2 ;;
        --pacman-conf)
            build_args+=(-C "$2")
            shift 2 ;;
        --bind)
            makechrootpkg_args+=(-D "$2")
            shift 2 ;;
        -T|--temp)
            makechrootpkg_args+=(-T)
            shift ;;
        -A|--ignorearch|--ignore-arch)
            makepkg_args+=(-A)
            makechrootpkg_makepkg_args+=(-A)
            shift ;;
        -L|--log)
            makepkg_args+=(-L)
            shift ;;
        --noconfirm|--no-confirm)
            makepkg_args+=(--noconfirm)
            shift ;;
        -l|--list)
            list=1
            shift ;;
        --repo-list)
            repo_list=1
            shift ;;
        -r|--rmdeps|--rm-deps)
            makepkg_args+=(-r)
            shift ;;
        -p|--print)
            build=0
            shift ;;
        -g|--git)
            snapshot=0
            shift ;;
        -t|--tar)
            snapshot=1
            shift ;;
        -u|--upgrades)
            update=1
            shift ;;
        --devel)
            devel=1
            shift ;;
        --allan|--nhehgvyf)
            rotate=1
            shift ;;
        --continue)
            download=0
            shift ;;
        --ignore)
            IFS=, read -a pkg -r <<< "$2"
            pkg_i+=("${pkg[@]}")
            shift 2 ;;
        --nover|--no-ver)
            chkver=0
            shift ;;
        --noview|--no-view)
            view=0
            shift ;;
        --provides)
            provides=1
            shift ;;
        -d|--database|--repo)
            repo=$2
            shift 2 ;;
        --root)
            root=$2
            shift 2 ;;
        *)
            shift
            break ;;
    esac
done

if ((rotate)); then
    if { hash rot13 && target=$(aur pkglist | shuf -n 1); } 2>/dev/null; then
        exec bash -c "{ aur \"$argv0\" -c \"$target\" && repo-elephant | rot13; } 2>&1 | rot13"
    else
        echo '?'; exit 16 # EBUSY
    fi
fi

if ((repo_list)); then
    pacconf | conf_file_repo
    exit
fi

if [[ ${repo-$AUR_REPO} ]]; then
    server=$(pacconf --single --repo="$repo" Server)
    server=${server#*://}
else
    mapfile -t conf < <(pacconf | conf_file_repo)

    case ${#conf[@]} in
        2) repo=${conf[0]}
           root=${conf[1]#*://} ;;
        0) error "$argv0: no file:// repository found"
           exit 2 ;;
        *) error "$argv0: repository choice is ambiguous (use --repo to specify)"
           printf -- '%s\n' "${conf[@]}" | paste - - | column -t >&2
           exit 2 ;;
    esac
fi

if ! (($# + update + list)); then
    error "$argv0: no targets specified"
    exit 1
fi

msg2 "Using [$repo] repository"
root=$(realpath -- "${root-$server}")

if ! [[ -w $root/$repo.db && -r $root/$repo.db ]]; then
    error "$argv0: $repo: permission denied (read-write)"
    exit 13
fi

if ((snapshot)); then
    aur_workdir=$AURDEST_SNAPSHOT
    fetch_args=(-L "$tmp"/patch -t)
else
    aur_workdir=$AURDEST
    fetch_args=(-L "$tmp"/patch -g)
fi

mkdir -p     "$aur_workdir"
chmod -c 700 "$aur_workdir"

cd_safe "$tmp"
mkdir patch

bsdcat "$root/$repo".db | db_namever | db_fill_empty >db_info

if ((devel)); then
  cut -f1 db_info | grep -E "$AURVCS" | xargs -I{} find "$aur_workdir" -maxdepth 1 -type d -name {} | xargs -r aur srcver >vcs_info || true
fi

if ((list)); then
    column -JN pkgname,pkgver -n "$repo" db_info
    exit
fi

{ for arg in "$@"; do
      case $arg in
          -) cat ;;
          *) printf -- '%s\n' "$arg" ;;
      esac
  done

  if ((update)); then
      aur vercmp <db_info | cut -d: -f1
      if ((devel)); then
        # At this point, mark **all** VCS packages for a potential update:
        # - if `chkver` is used, all up-to-date packages will be filtered out, and user will only be presented with obsolete packages
        # - if `chkver` is not used, we will not check versions and present all VCS packages for an update
        cut -f1 vcs_info
      fi
  fi
} >argv

if [[ -s argv ]]; then
    aur deps-rpc -t <argv >pkginfo
else
    plain "there is nothing to do"
    exit
fi

{ if ((${#pkg_i[@]})); then
      printf -- >&2 'warning: ignoring %s package\n' "${pkg_i[@]}"
      printf -- '%s\n' "${pkg_i[@]}"
  fi

  if ((provides)); then
      # note: this uses pacman's copy of the repo (as used by makepkg -s)
      cut -f1 pkginfo | complement argv | aur rfilter -d "$repo"
  fi
} >filter

{ if ((chkver)); then
      # 1. Unconditionally sync new packages (both regular and vcs) that are not in the repo yet (not in `db_info`)
      cut -f1 pkginfo | grep -Fxvf <(cut -f1 db_info) || true

      # 2. Sync packages (both regular and vcs) that are already in the repo, that are outdated according to AUR RPC
      #    (whose current versions in `db_info` are older than versions in `pkginfo`)
      #
      #    vcs packages can be marked here as outdated if maintainer updates the static pkgver in PKGBUILD.
      #    We expect that maintainers will do that for any major changes in PKGBUILD (such as changing source or build commands).
      aur vercmp -p <(cut -f1,3 pkginfo) <db_info | cut -d: -f1

      # 3. Sync vcs packages that are already in the repo, that are outdated according to aur-srcver
      #    (whose current versions in `db_info` are older than versions in `vcs_info` - not in `pkginfo`)
      ((devel)) && aur vercmp -p vcs_info <db_info | cut -d: -f1
  else
      cut -f1 pkginfo
  fi
} >pkgs_to_sync

lib32 <pkgs_to_sync | complement filter >queue_0

if [[ -s queue_0 ]]; then
    select_pkgbase queue_0 pkginfo | cut -f2 >queue
else
    plain "there is nothing to do"
    exit
fi

cd_safe "$aur_workdir"

if ((download)); then
    xargs -a "$tmp"/queue aur fetch "${fetch_args[@]}"
fi

if ((view)); then
    if [[ -v AUR_PAGER ]]; then
        # link build files in the queue (relative links)
        xargs -a "$tmp"/queue ln -t "$tmp_view" -rs

        # move diffs if available
        files=("$tmp"/patch/*)

        if [[ -f ${files[0]} ]]; then
            mv "${files[@]}" "$tmp_view"
        fi

        # start file manager in link directory
        command -- $AUR_PAGER "$tmp_view"
    else
        printf '%s\n' "$tmp"/patch/* | cat - "$tmp"/queue \
            | xargs -I{} find {} -maxdepth 1 | viewer
    fi
fi

if ((build)); then
    build_args+=(-d "$repo" -r "$root" -a "$tmp"/queue)

    if ((chroot)); then
        aur build "${build_args[@]}" -- "${makechrootpkg_args[@]}" \
            -- "${makechrootpkg_makepkg_args[@]}"
    else
        aur build "${build_args[@]}" -- "${makepkg_args[@]}"
    fi
else
    xargs -a "$tmp"/queue printf -- "$(pwd -P)/%s\\n"
fi

# vim: set et sw=4 sts=4 ft=sh:
