#!/bin/bash
# aur-search - search for AUR packages
set -o pipefail
readonly argv0=search
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# default options
query_type=search
search_by=name-desc
sort_key=Name

parse_short() {
    jq -r --arg key "$1" '[.results[]] | sort_by(.[$key])[] | [
        .Name,
        .Version,
        .NumVotes,
        .Maintainer   // "-",
        .OutOfDate    // "-",
        .Description
        ] | @tsv'
}

output_short() {
    local Name Version NumVotes Maintainer OutOfDate Description

    while IFS=$'\t' read -r Name Version NumVotes Maintainer OutOfDate Description ; do
        [[ "$OutOfDate"  == "-" ]] && OutOfDate=""  || OutOfDate="(Out-of-date: $(date -d @"$OutOfDate" '+%d %B %Y'))"
        [[ "$Maintainer" != "-" ]] && Maintainer="" || Maintainer="(Orphaned)"
        printf "${BLUE}aur/${ALL_OFF}${BOLD}%s ${GREEN}%s ${ALL_OFF}(%s) ${RED}%s %s${ALL_OFF}\\n    %s\\n" \
               "$Name" "$Version" "$NumVotes" "$Maintainer" "$OutOfDate" "$Description"
    done
}

parse_long() {
    jq -r --arg key "$1" '[.results[]] | sort_by(.[$key])[] | [
        .Name,
        .PackageBase,
        .Version,
        .Description,
        .URL,
        (.Keywords       // ["-"] | join(" ")),
        (.License        // ["-"] | join(" ")),
        .NumVotes,
        .Popularity,
        .OutOfDate       // "-",
        .Maintainer      // "-",
        .FirstSubmitted,
        .LastModified
        ] | @tsv'
}

output_long() {
    local Name PackageBase Version Description URL Keywords License
    local NumVotes Popularity OutOfDate Maintainer FirstSubmitted LastModified

    while IFS=$'\t' read -r Name PackageBase Version Description URL Keywords License NumVotes Popularity OutOfDate Maintainer FirstSubmitted LastModified ; do
        printf -- 'Name:          %s\n' "$Name"
        printf -- 'Base:          %s\n' "$PackageBase"
        printf -- 'Version:       %s\n' "$Version"
        printf -- 'Description:   %s\n' "$Description"
        printf -- 'URL:           %s\n' "$URL"
        printf -- 'Keywords:      %s\n' "$Keywords"
        printf -- 'License:       %s\n' "$License"
        printf -- 'Votes:         %s\n' "$NumVotes"
        printf -- 'Popularity:    %s\n' "$Popularity"
        printf -- 'Out Of Date:   %s\n' "$OutOfDate"
        printf -- 'Maintainer:    %s\n' "$Maintainer"
        printf -- 'Submitted:     %s\n' "$(date -d @"$FirstSubmitted" '+%c')"
        printf -- 'Last Modified: %s\n' "$(date -d @"$LastModified" '+%c')"
        printf '\n'
    done
}

usage() {
    printf -- >&2 'usage: %s: [-imnrv] [-k key] package [package...]\n' "$argv0"
    exit 1
}

source /usr/share/makepkg/util/message.sh || exit

if [[ -t 2 && ! -o xtrace ]]; then
    colorize
fi

unset format
while getopts :isdmnqvk: opt; do
    case $opt in
        i) query_type=info      ;;
        s) query_type=search    ;;
        d) search_by=name-desc  ;;
        m) search_by=maintainer ;;
        n) search_by=name       ;;
        q) format=short         ;;
        v) format=long          ;;
        k) sort_key=$OPTARG     ;;
        *) usage                ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

if ((!$#)); then
    usage
fi

# set format depending on query type (#319)
case $query_type in
      info) format=${format-long}  ;;
    search) format=${format-short} ;;
esac

# set parsers
case $format in
     long) parse() { parse_long  "$sort_key"; } ;;
    short) parse() { parse_short "$sort_key"; } ;;
esac

# set output
case $format in
     long) output() { output_long;  } ;;
    short) output() { output_short; } ;;
esac

# prepare for execution

trap_exit() {
    if [[ ! -o xtrace ]]; then
        rm -rf "$tmp"
    fi
}

tmp=$(mktemp -dt "$argv0".XXXXXXXX)
trap 'trap_exit' EXIT

source /usr/share/makepkg/util/util.sh
cd_safe "$tmp"

# pipeline
for query in "$@"; do
    printf -- '%s\n' "$query" | aur rpc -t "$query_type" -b "$search_by" | parse > query_results
    if [[ -f query_results_combined ]]; then
        mv query_results_combined query_results_prev
        grep -Fxf query_results query_results_prev > query_results_combined
    else
        mv query_results query_results_combined
    fi
done

output <query_results_combined

# vim: set et sw=4 sts=4 ft=sh:
