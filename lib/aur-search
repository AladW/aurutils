#!/bin/bash
# aur-search - search for AUR packages
set -o pipefail
readonly argv0=search
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# default options
query_type=search
search_by=name-desc
sort_key=Name

fold_column() {
    local prefix=$1 offset=${#1}
    local columns
    columns=$(tput cols)

    if ((columns < offset)); then
        printf -- >&2 'offset too large\n'
        return 1
    fi

    fold -sw "$((columns - offset))" | while IFS= read -r; do
        if ((!counter)); then
            printf -- '%s%s\n' "$prefix" "$REPLY"
        else
            printf -- '%*s'  "$offset"
            printf -- '%s\n' "$REPLY"
        fi
        ((counter++))
    done
}

fold_column_str() {
    local prefix=$1 string=$2
    
    printf -- '%s\n' "$string" | fold_columns "$prefix"
}

json_short() {
    local Name Version NumVotes Maintainer OutOfDate Description

    jq -r --arg key "$1" '[.results[]] | sort_by(.[$key])[] | .Name,
        .Version,
        .NumVotes,
        .Maintainer // "",
        .OutOfDate  // "",
        .Description' | while
    {
        read -r Name
        read -r Version
        read -r NumVotes
        read -r Maintainer
        read -r OutOfDate
        read -r Description
    }; do
        [[ "$OutOfDate"  ]] && OutOfDate="(Out-of-date: $(date -d @"$OutOfDate" '+%d %B %Y'))"
        [[ "$Maintainer" ]] && unset Maintainer

        printf "${BLUE}aur/${ALL_OFF}${BOLD}%s ${GREEN}%s ${ALL_OFF}(%s) ${RED}%s %s${ALL_OFF}\\n    %s\\n" \
               "$Name" "$Version" "$NumVotes" "${Maintainer+(Orphaned)}" "$OutOfDate" "$Description"
    done
}

json_long() {
    local Name PackageBase Version Description URL Keywords License Depends MakeDepends
    local NumVotes Popularity OutOfDate Maintainer FirstSubmitted LastModified

    jq -r --arg key "$1" '[.results[]] | sort_by(.[$key])[] | .Name,
        .PackageBase,
        .Version,
        .Description,
        .URL,
        (.Keywords    // ["(null)"] | join(" ")),
        (.License     // ["(null)"] | join(" ")),
        (.Depends     // ["(null)"] | join(" ")),
        (.MakeDepends // ["(null)"] | join(" ")),
        .NumVotes,
        .Popularity,
        .OutOfDate,
        .Maintainer,
        .FirstSubmitted,
        .LastModified' | while
    {
        read -r Name
        read -r PackageBase
        read -r Version
        read -r Description
        read -r URL
        read -r Keywords
        read -r License
        read -r Depends
        read -r MakeDepends
        read -r NumVotes
        read -r Popularity
        read -r OutOfDate
        read -r Maintainer
        read -r FirstSubmitted
        read -r LastModified
    }; do
        # long fields
        find_column_str 'Name          : ' "$Name"
        find_column_str 'Base          : ' "$PackageBase"
        find_column_str 'Version       : ' "$Version"
        find_column_str 'Description   : ' "$Description"
        find_column_str 'URL           : ' "$URL"
        fold_column_str 'Keywords      : ' "$Keywords"
        fold_column_str 'License       : ' "$License"
        fold_column_str 'Depends On    : ' "$Depends"
        find_column_str 'Makedepends   : ' "$MakeDepends"

        # short fields
        printf -- 'Votes         : %s\n' "$NumVotes"
        printf -- 'Popularity    : %s\n' "$Popularity"
        printf -- 'Out Of Date   : %s\n' "$OutOfDate"
        printf -- 'Maintainer    : %s\n' "$Maintainer"
        printf -- 'Submitted     : %s\n' "$(date -d @"$FirstSubmitted" '+%c')"
        printf -- 'Last Modified : %s\n' "$(date -d @"$LastModified" '+%c')"
        printf '\n'
    done
}

usage() {
    printf -- >&2 'usage: %s: [-imnrv] [-k key] package [package...]\n' "$argv0"
    exit 1
}

source /usr/share/makepkg/util/message.sh || exit

if [[ -t 2 && ! -o xtrace ]]; then
    colorize
fi

unset format
while getopts :isdmnqvk: opt; do
    case $opt in
        i) query_type=info      ;;
        s) query_type=search    ;;
        d) search_by=name-desc  ;;
        m) search_by=maintainer ;;
        n) search_by=name       ;;
        q) format=short         ;;
        v) format=long          ;;
        k) sort_key=$OPTARG     ;;
        *) usage                ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

if ((!$#)); then
    usage
fi

# set format depending on query type (#319)
case $query_type in
      info) format=${format-long}  ;;
    search) format=${format-short} ;;
esac

# set filters
case $format in
     long) parse() { json_long  "$sort_key"; } ;;
    short) parse() { json_short "$sort_key"; } ;;
esac

# pipeline
printf -- '%s\n' "$@" | aur rpc -t "$query_type" -b "$search_by" | parse

# vim: set et sw=4 sts=4 ft=sh:
