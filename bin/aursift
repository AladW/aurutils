#!/bin/bash
#
# Read package names from stdin separated by the IFS and produces a
# list of packages not provided in the official repositories.
#
readonly argv0=aursift
readonly arch_repo=(core extra testing community{,-testing} multilib{,-testing})
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

declare -a siftargs=() repo=()
declare -A pkgset

# Takes a set of package names to create "package virtual" pairs,
# querying both provides and replaces fields.
provides() {
    expac '%n %R %S' -Sv "$@" | awk '{
        for(i = 2; i <= NF; ++i) {
	    printf("%s\t%s\n", $1, $i) | "sort -u"
	}
    }'
}
readonly -f provides

source /usr/share/makepkg/util.sh || exit

if [[ -t 2 ]]; then
    colorize
fi

# Use an additional indexed array to preserve input order.
readarray -t all

for p in "${all[@]}"; do
    siftargs+=("--satisfies=$p")
    pkgset[$p]=1
done

if [[ ${pkgset[*]} ]]; then
    for p in "${arch_repo[@]}"; do
        siftargs+=("--repo=$p")
    done
else
    error "$argv0: no data available"
    exit 61
fi

# https://github.com/andrewgregory/pacutils/issues/3
readarray -t query < <(pacsift --sync --exact "${siftargs[@]}" <&-)

if [[ ${query[*]} ]]; then
    while read -r p v; do
        p=${p#*/}

        if [[ ${pkgset[$p]} ]]; then
            repo+=("$p")
        fi

        if [[ ${pkgset[$v]} ]]; then
            plain "virtual dependency $v provided by $p"
            repo+=("$v")
        fi
    done < <(provides "${query[@]}")
else
    msg2 "No matches in the official repositories"
fi

# Print the relative complement between repo provided dependencies and
# all required dependencies. all \ repo
grep -Fxvf <(printf '%s\n' "${repo[@]}") <(printf '%s\n' "${all[@]}")

# vim: set et sw=4 sts=4 ft=sh:
